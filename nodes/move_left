#!/usr/bin/env python


"""

PUBLSIHERS:
    +

SUBSCRIBERS:
    +
"""

#from __future__ import division

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr
from tf.transformations import quaternion_matrix
from tf.transformations import quaternion_from_euler
from tf.transformations import euler_from_matrix



class LeftArm(object):
    """ manipulates baxters left arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(LeftArm, self).__init__()

        #joint_state_topic = ['joint_states:=/joint_states_desired']
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)

        rospy.init_node("left_arm", anonymous=True)


        baxter_interface.RobotEnable().enable()
        rospy.sleep(0.25)
        print("Baxter is enabled")


        #moveit_commander.roscpp_initialize(sys.argv)
        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()


        # add table
        self.add_box()


        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.tolerance = 0.01
        self.left_group.set_goal_position_tolerance(self.tolerance)
        self.left_group.set_goal_orientation_tolerance(self.tolerance)
        self.left_group.set_planning_time(5.0)
        self.left_group.allow_replanning(True)
        self.left_group.set_max_velocity_scaling_factor(0.6)
        self.left_group.set_max_acceleration_scaling_factor(0.6)

        # gripper
        self.left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        self.left_gripper.reboot()
        # Calibrate Gripper
        self.left_gripper.calibrate()
        # Open Gripper
        self.left_gripper.open()

        # Initialize attribute for desired EE Pose
        self.pose_goal = Pose()
        # Amount to pull back pre and post grip (approach, retreat)
        self.standoff = 0.2


        # trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)


        # subscribe to gun pose
        #self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.go_to_goal)

        print("done initializing")

        #self.robot_state = self.robot.get_current_state()
        #print(self.robot_state)
        #print(self.left_group.get_current_pose().pose)
        #rospy.sleep(3)


        """
        self.planning_frame = self.left_group.get_planning_frame()
        rospy.loginfo("========== Reference frame: %s" % self.planning_frame)
        # Get End Effector link name for this group
        self.eef_link = self.left_group.get_end_effector_link()
        rospy.loginfo("========== End effector: %s" % self.eef_link)
        # Get list of all groups in the robot
        self.group_names = self.robot.get_group_names()
        rospy.loginfo("========== Robot Groups: %s" % self.robot.get_group_names())
        """


    def gun_callback(self, msg):
        """ callback for the pose of the gun

        Args:
            msg (Pose): pose of gun
        """
        #self.go_to_goal(msg)
        pass




    def go_to_goal(self, msg):
        """ moves baxters left end effector to a pose goal """


        # compute transformation of gun relative to EE
        Teg = self.get_transform(msg)

        # comput transformation of EE relative to baxter
        left_EE_pose = self.left_group.get_current_pose().pose
        print("EE pose")
        print(left_EE_pose)

        Tbe = self.get_transform(left_EE_pose)
        # tranformation from baxter to gun
        Tbg = np.dot(Tbe, Teg)

        # pose of gun relative to baxter
        quat, trans = self.extract_pose(Tbg)


        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()

        # move hand to standoff behind the gun
        pose_goal.orientation.x = quat[0]
        pose_goal.orientation.y = quat[1]
        pose_goal.orientation.z = quat[2]
        pose_goal.orientation.w = quat[3]

        #"""
        pose_goal.orientation.x = 0.005
        pose_goal.orientation.y = 0.70
        pose_goal.orientation.z = 0.000
        pose_goal.orientation.w = 0.70
        #"""

        pose_goal.position.x = trans[0]
        pose_goal.position.y = trans[1]
        pose_goal.position.z = trans[2]


        print("-------------")
        print("current goal")
        print(pose_goal)

        self.left_group.set_pose_target(pose_goal)

        # plan to path goal
        plan = self.left_group.plan()
        self.display_trajectory(plan)

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()

        # test if made it to pre-pick up position
        left_EE_pose = self.left_group.get_current_pose().pose
        if self.made_it(pose_goal, left_EE_pose):
            print("End Effector Behind gun!")

        else:
            print("End Effector did Not make it to gun!")


        print("============ Left Gripper Behind Gun")
        print("============ Press `Enter` to finish movement")
        raw_input()


        # position EE at handle of gun
        pose_goal.orientation.x = quat[0]
        pose_goal.orientation.y = quat[1]
        pose_goal.orientation.z = quat[2]
        pose_goal.orientation.w = quat[3]
        pose_goal.position.x = trans[0]
        pose_goal.position.y = trans[1]
        pose_goal.position.z = trans[2]


        self.left_group.set_pose_target(pose_goal)

        # plan to goal
        plan = self.left_group.plan()
        self.display_trajectory(plan)

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()


        rospy.sleep(2)


        #current_pose = self.left_group.get_current_pose(self.left_group.get_end_effector_link()).pose
        left_EE_pose = self.left_group.get_current_pose().pose
        print(left_EE_pose)
        #print(self.left_group.get_end_effector_link())

        if self.made_it(pose_goal, left_EE_pose):
            print("Ready to grasp gun!")

        else:
            print("Not ready to grasp gun!")


        print("============ Press `Enter` to close left gripper")
        raw_input()
        self.left_gripper.close()



    def display_trajectory(self, plan):
        """ Published planned trajectory in rviz

        Args:
            plan (): motion plan to goal
        """

        display_traj = moveit_msgs.msg.DisplayTrajectory()
        display_traj.trajectory_start = self.robot.get_current_state()
        display_traj.trajectory.append(plan)
        self.display_trajectory_publisher.publish(display_traj);



    def get_transform(self, pose):
        """ computes the transformation matrix given a pose msg

        Args:
            pose (Pose): pose of a rigid body

        Returns:
            T (np.array): homogenous transformation matrix
        """

        quat_list = [pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w]

        homo_rot = quaternion_matrix(quat_list)

        T = np.array([[homo_rot[0][0], homo_rot[0][1], homo_rot[0][2], pose.position.x],
                      [homo_rot[1][0], homo_rot[1][1], homo_rot[1][2], pose.position.y],
                      [homo_rot[2][0], homo_rot[2][1], homo_rot[2][2], pose.position.z],
                      [0,              0,              0,              1]])


        return T


    def extract_pose(self, T):
        """ extracts the quaternion and translation vector from a homogenous
        tranformation matrix

        Args:
            T (np.array): homogenous transformation matrix

        Returns:
            quat (np.array): quaternion represting orientation of rigid body
            trans (np.array): translation vector represting position of rigid body
        """

        # extract euler angles
        rot = np.array([[T[0][0], T[0][1], T[0][2]],
                        [T[1][0], T[1][1], T[1][2]],
                        [T[2][0], T[2][1], T[2][2]]])


        ax, ay, az = euler_from_matrix(rot)
        quat = quaternion_from_euler(ax, ay, az)

        trans = np.array([T[0][3], T[1][3], T[2][3]])

        return quat, trans


    def made_it(self, goal, actual):
        """ Test if end effector made it to target

        Args:
        goal (Pose): target for robot
        actual (Pose): where robot actually is

        Returns:
        bool: True for success
        """

        goal = pose_to_list(goal)
        actual = pose_to_list(actual)

        for index in range(len(goal)):
            if abs(actual[index] - goal[index]) > self.tolerance:
                return False

        return True



    def add_box(self, timeout=4):
        """ Adds a box to rviz """

        # Add Objects to Planning Scene
        self.box_name = 'table'
        self.box_pose = PoseStamped()
        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.box_pose.header.frame_id = "base"
        self.box_pose.pose.position.x = 0.5
        self.box_pose.pose.position.z = -0.3095
        self.box_pose.pose.orientation.w = 1.0
        # Length, Width, Height
        self.scene.add_box(self.box_name, self.box_pose, size=(0.6, 0.8, 0.1))
        # return self.wait_for_state_update(box_is_known=True, timeout=timeout)



def main():

    #rospy.init_node("left_arm", anonymous=True)

    try:
        left_arm = LeftArm()

        #print("============ Press `Enter` to execute a movement using a pose goal")
        #raw_input()
        #left_arm.go_to_goal()


        #print("============ Press `Enter` to close left gripper")
        #raw_input()
        #left_arm.left_gripper.close()


    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()




"""
pose_goal.orientation.x = 0.70
pose_goal.orientation.y = 0.027
pose_goal.orientation.z = 0.713
pose_goal.orientation.w = 0.04

pose_goal.position.x = 0.4 - self.standoff
pose_goal.position.y = 0.1
pose_goal.position.z = 0.4
"""










#
