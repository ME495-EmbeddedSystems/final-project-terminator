#!/usr/bin/env python


"""

PUBLSIHERS:
    +

SUBSCRIBERS:
    +
"""

from __future__ import division

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr
from tf.transformations import quaternion_matrix
from tf.transformations import quaternion_from_euler
from tf.transformations import euler_from_matrix

from terminator import*


class LeftArm(object):
    """ manipulates baxters left arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(LeftArm, self).__init__()

        #joint_state_topic = ['joint_states:=/joint_states_desired']
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)


        # TODO: move this to the commander main node
        baxter_interface.RobotEnable().enable()
        rospy.sleep(0.25)
        print("Baxter is enabled")


        #moveit_commander.roscpp_initialize(sys.argv)
        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()

        # size of April tag
        # important for placement of gripper
        self.tag = 0.0873125


        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.position_tol = 0.03
        self.orientation_tol = 0.3

        self.left_group.set_goal_position_tolerance(self.position_tol)
        self.left_group.set_goal_orientation_tolerance(self.orientation_tol)
        self.left_group.set_planning_time(10.0)
        self.left_group.allow_replanning(True)
        self.left_group.set_max_velocity_scaling_factor(0.2)
        self.left_group.set_max_acceleration_scaling_factor(0.1)

        # gripper
        self.left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        self.left_gripper.reboot()
        # Calibrate Gripper
        self.left_gripper.calibrate()
        # Open Gripper
        self.left_gripper.open()

        self.orientation_x = -0.003
        self.orientation_y = 0.696
        self.orientation_z = -0.0048
        self.orientation_w = 0.717


        # Amount to pull back pre and post grip (approach, retreat)
        self.prestandoff = 0.15
        self.poststandoff = 0.2
        # vertical distance from gun to tag
        self.vert_tg = 0.2413

        # position adjustment parameters
        self.x_coord = 0.127
        self.y_coord = 0.0762
        self.z_coord = 0.0254

        # trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)


        # init pose goal for right EE
        init_goal = geometry_msgs.msg.Pose()
        init_goal.orientation.x = 0.065
        init_goal.orientation.y = 0.766
        init_goal.orientation.z = -0.022
        init_goal.orientation.w = 0.639

        init_goal.position.x = 0.415
        init_goal.position.y = 0.531
        init_goal.position.z = -0.15



        # place arm in init position
        arm_init_pose(init_goal, self.left_group, self.position_tol, self.orientation_tol, "Left")

        print("Done Initializing Baxter")


        # subscribe to gun pose
        #self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.go_to_goal)
        #self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.go_to_goal_waypoints)
        self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.pick_up_gun)


    def pick_up_gun(self, msg):
        """ callback function for Subscriber to /gun_pose

        The trajectory is divided into three stages

        1) move gripper to standoff location
        2) move gripper to handle
        3) grasp the gun
        4) pick up gun vertically to standoff location

        Args:
            msg (Pose): pose of the april tag
        """

        # stage 1
        print("============ Move to gun ============")
        pre_grasp = self.move_gripper(msg, pre_standoff=True)

        # stage 2
        print("============ Move to gun handle ============")
        grasp_handle = self.move_gripper(msg)

        # stage 3
        if pre_grasp and grasp_handle:
            print("============ Press `Enter` to close left gripper ============")
            raw_input()
            self.left_gripper.close()
            rospy.sleep(2)

        # stage 4
        print("============ Lift gun off Table ============")
        post_grasp = self.move_gripper(msg, post_standoff=True)




    def move_gripper(self, msg, pre_standoff=False, post_standoff=False):
        """ moves gripper to a goal pose

        Args:
            msg (Pose): pose of the april tag

        Returns:
            success (bool): True gripper makes it to pre-grasp standoff pose
        """

        # get pose of EE
        left_EE_pose = self.left_group.get_current_pose().pose

        # compute transformation of gun relative to EE
        Teg = get_transform(msg)

        Tbe = get_transform(left_EE_pose)
        # tranformation from baxter to gun
        Tbg = np.dot(Tbe, Teg)

        # pose of gun relative to baxter
        quat, trans = extract_pose(Tbg)


        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()

        if pre_standoff:
            print("pre-standoff")
            # translation is based on location of April tag
            # pose_goal.position.x = msg.position.x + left_EE_pose.position.x - self.standoff
            # pose_goal.position.y = msg.position.y + left_EE_pose.position.y + self.tag/2
            # pose_goal.position.z = msg.position.z + left_EE_pose.position.z + self.tag/2

            pose_goal.position.x = trans[0] - self.prestandoff
            pose_goal.position.y = trans[1] + self.tag/2 + self.y_coord
            pose_goal.position.z = trans[2] + self.tag/2 + self.vert_tg


        elif post_standoff:
            print("post-standoff")
            # lift gun off table vertically
            pose_goal.position.x = left_EE_pose.position.x
            pose_goal.position.y = left_EE_pose.position.y
            pose_goal.position.z = left_EE_pose.position.z + self.poststandoff

        else:
            print("grasp")
            # move to grasp pose
            pose_goal.position.x = left_EE_pose.position.x + self.x_coord
            pose_goal.position.y = left_EE_pose.position.y
            pose_goal.position.z = left_EE_pose.position.z + self.z_coord


        # use pre-defined orientation
        pose_goal.orientation.x = self.orientation_x
        pose_goal.orientation.y = self.orientation_y
        pose_goal.orientation.z = self.orientation_z
        pose_goal.orientation.w = self.orientation_w

        success = False

        while not success:
            # develop a trajectory of waypoints
            plan, fraction = plan_cartesian_path(left_EE_pose, pose_goal, self.left_group)

            print("The fraction of path covered")
            print(fraction)

            # display plan in rviz
            display_trajectory(plan, self.robot, self.display_trajectory_publisher)

            rospy.sleep(2)

            print("============ Press `Enter` to move gripper ============")
            raw_input()

            try:
                # execute path
                self.left_group.execute(plan, wait=True)
                self.left_group.stop()
                self.left_group.clear_pose_targets()

                # wait for baxter to get to goal
                rospy.sleep(2)

            except (rospy.ServiceException, rospy.ROSException), e:
                rospy.loginfo("Service call failed: %s" % (e,))

            # test if made it to pre-pick up position
            left_EE_pose = self.left_group.get_current_pose().pose

            if made_it(pose_goal, left_EE_pose, self.position_tol, self.orientation_tol):
                print("Goal Reached")
                success = True

            else:
                print("Goal Not Reached!")
                print("EE pose")
                print(left_EE_pose)

                print("Goal")
                print(pose_goal)

        return success



    def aim(self):
        """ callback for subscriber to /targetBox

        Positions the y and z coordinates of the left EE to align with the target

        Args:
            msg
        """


        # move to initial shooting position
        # restrict z motion is x-axis
        # get pose of EE
        left_EE_pose = self.left_group.get_current_pose().pose


        pose_goal = geometry_msgs.msg.Pose()
        pose_goal.orientation.x = 0.065
        pose_goal.orientation.y = 0.766
        pose_goal.orientation.z = -0.022
        pose_goal.orientation.w = 0.639

        pose_goal.position.x = 0.415
        pose_goal.position.y = 0.531
        pose_goal.position.z = -0.15


        plan, fraction = plan_cartesian_path(left_EE_pose, pose_goal, self.left_group)
        print("The fraction of path covered")
        print(fraction)

        display_trajectory(plan, self.robot, self.display_trajectory_publisher)

        rospy.sleep(2)













def main():

    rospy.init_node("left_arm", anonymous=True)

    try:
        left_arm = LeftArm()

        #print("============ Press `Enter` to execute a movement using a pose goal")
        # raw_input()
        # #left_arm.go_to_goal()
        # msg = geometry_msgs.msg.Pose()
        # msg.orientation.x = 0.027
        # msg.orientation.y = 0.76
        # msg.orientation.z = -0.020
        # msg.orientation.w = 0.65
        #
        # msg.position.x = 0.5
        # msg.position.y = 0
        # msg.position.z = 0
        #
        # #left_arm.go_to_goal_waypoints(msg)
        # left_arm.pick_up_gun(msg)
        # #print("============ Press `Enter` to close left gripper")
        #raw_input()
        #left_arm.left_gripper.close()


    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()












#
