#!/usr/bin/env python


"""

PUBLSIHERS:
    +

SUBSCRIBERS:
    +
"""

from __future__ import division

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr
from tf.transformations import quaternion_matrix
from tf.transformations import quaternion_from_euler
from tf.transformations import euler_from_matrix



class LeftArm(object):
    """ manipulates baxters left arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(LeftArm, self).__init__()

        #joint_state_topic = ['joint_states:=/joint_states_desired']
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)

        rospy.init_node("left_arm", anonymous=True)


        baxter_interface.RobotEnable().enable()
        rospy.sleep(0.25)
        print("Baxter is enabled")


        #moveit_commander.roscpp_initialize(sys.argv)
        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()


        # add table
        self.add_box()

        self.tag = 0.0873125


        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.position_tol = 0.01
        self.orientation_tol = 0.3

        self.tolerance = self.orientation_tol

        self.left_group.set_goal_position_tolerance(self.position_tol)
        self.left_group.set_goal_orientation_tolerance(self.orientation_tol)
        self.left_group.set_planning_time(10.0)
        self.left_group.allow_replanning(True)
        self.left_group.set_max_velocity_scaling_factor(0.4)
        self.left_group.set_max_acceleration_scaling_factor(0.4)

        # gripper
        self.left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        self.left_gripper.reboot()
        # Calibrate Gripper
        self.left_gripper.calibrate()
        # Open Gripper
        self.left_gripper.open()

        # Initialize attribute for desired EE Pose
        self.pose_goal = Pose()
        # Amount to pull back pre and post grip (approach, retreat)
        self.standoff = 0.2


        # trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)


        # subscribe to gun pose
        #self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.go_to_goal)
        self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.go_to_goal_waypoints)

        print("done initializing")



    def gun_callback(self, msg):
        """ callback for the pose of the gun

        Args:
            msg (Pose): pose of gun
        """
        #self.go_to_goal(msg)
        pass


    def plan_cartesian_path(self, left_EE_pose, goal):
        """ plans a cartesian path using waypoints """

        print("lets plan")

        iter = 100
        waypoints = []

        xiter = np.linspace(left_EE_pose.position.x, goal.position.x, iter)
        yiter = np.linspace(left_EE_pose.position.y, goal.position.y, iter)
        ziter = np.linspace(left_EE_pose.position.z, goal.position.z, iter)

        for i in range(iter):
            p = copy.deepcopy(left_EE_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]

            # last waypoint use pose of goal
            if i == iter - 1:

                p = copy.deepcopy(goal)
                p.position.x = xiter[i]
                p.position.y = yiter[i]
                p.position.z = ziter[i]

            waypoints.append(p)


        plan, fraction = self.left_group.compute_cartesian_path(waypoints, 0.01, 0.0)

        return plan, fraction





    def test_waypoints(self):
        """ moves baxters left end effector to a pose goal """


        # comput transformation of EE relative to baxter
        left_EE_pose = self.left_group.get_current_pose().pose
        print("EE pose")
        print(left_EE_pose)


        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()

        pose_goal.position.x = 0.4
        pose_goal.position.y = 0.1
        pose_goal.position.z = 0.4

        pose_goal.orientation.w = 1



        plan, fraction = self.plan_cartesian_path(left_EE_pose, pose_goal)

        print("The fraction")
        print(fraction)

        self.display_trajectory(plan)

        print("============ Press `Enter` to finish movement")
        raw_input()

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()



    def go_to_goal_waypoints(self, msg):
        """ moves baxters left end effector to a pose goal """

        # compute transformation of gun relative to EE
        Teg = self.get_transform(msg)

        # comput transformation of EE relative to baxter
        left_EE_pose = self.left_group.get_current_pose().pose
        print("EE pose")
        print(left_EE_pose)

        Tbe = self.get_transform(left_EE_pose)
        # tranformation from baxter to gun
        Tbg = np.dot(Tbe, Teg)

        # pose of gun relative to baxter
        quat, trans = self.extract_pose(Tbg)


        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()


        pose_goal.position.x = trans[0] - self.standoff
        pose_goal.position.y = trans[1] + self.tag/2
        pose_goal.position.z = trans[2] + self.tag/2

        pose_goal.orientation.x = 0.027
        pose_goal.orientation.y = 0.76
        pose_goal.orientation.z = -0.020
        pose_goal.orientation.w = 0.65



        plan, fraction = self.plan_cartesian_path(left_EE_pose, pose_goal)

        print("The fraction")
        print(fraction)

        self.display_trajectory(plan)

        rospy.sleep(2)

        print("============ Press `Enter` to finish movement")
        raw_input()

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()


        rospy.sleep(4)

        # test if made it to pre-pick up position
        left_EE_pose = self.left_group.get_current_pose().pose
        if self.made_it(pose_goal, left_EE_pose):
            print("End Effector Behind gun!")

        else:
            print("End Effector did Not make it to gun!")




    def go_to_goal(self, msg):
        """ moves baxters left end effector to a pose goal """


        # compute transformation of gun relative to EE
        Teg = self.get_transform(msg)

        # comput transformation of EE relative to baxter
        left_EE_pose = self.left_group.get_current_pose().pose
        print("EE pose")
        print(left_EE_pose)

        Tbe = self.get_transform(left_EE_pose)
        # tranformation from baxter to gun
        Tbg = np.dot(Tbe, Teg)

        # pose of gun relative to baxter
        quat, trans = self.extract_pose(Tbg)


        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()

        """
        # move hand to standoff behind the gun
        pose_goal.orientation.x = quat[0]
        pose_goal.orientation.y = quat[1]
        pose_goal.orientation.z = quat[2]
        pose_goal.orientation.w = quat[3]

        pose_goal.orientation.x = -0.017
        pose_goal.orientation.y = 0.72
        pose_goal.orientation.z = -0.002
        pose_goal.orientation.w = 0.70
        """

        pose_goal.position.x = trans[0] - self.standoff
        pose_goal.position.y = trans[1] + self.tag/2
        pose_goal.position.z = trans[2] + self.tag/2

        """
        pose_goal.position.x = 0.86
        pose_goal.position.y = 0.5
        pose_goal.position.z = -0.23
        """


        #pose_goal.orientation.w = 0.1

        #"""
        pose_goal.orientation.x = 0.027
        pose_goal.orientation.y = 0.76
        pose_goal.orientation.z = -0.020
        pose_goal.orientation.w = 0.65
        #"""
        """
        pose_goal.position.x = 0.97
        pose_goal.position.y = 0.30
        pose_goal.position.z = -0.15
        """

        print("-------------")
        print("current goal")
        print(pose_goal)

        self.left_group.set_pose_target(pose_goal)

        # plan to path goal
        plan = self.left_group.plan()
        self.display_trajectory(plan)

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()

        rospy.sleep(2)

        # test if made it to pre-pick up position
        left_EE_pose = self.left_group.get_current_pose().pose
        if self.made_it(pose_goal, left_EE_pose):
            print("End Effector Behind gun!")

        else:
            print("End Effector did Not make it to gun!")


        print("============ Left Gripper Behind Gun")
        print("============ Press `Enter` to finish movement")
        raw_input()


        # position EE at handle of gun

        pose_goal.position.x = trans[0]
        pose_goal.position.y = trans[1] + self.tag/2
        pose_goal.position.z = trans[2] + self.tag/2


        self.left_group.set_pose_target(pose_goal)

        # plan to goal
        plan = self.left_group.plan()
        self.display_trajectory(plan)

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()


        rospy.sleep(2)


        #current_pose = self.left_group.get_current_pose(self.left_group.get_end_effector_link()).pose
        left_EE_pose = self.left_group.get_current_pose().pose
        print(left_EE_pose)
        #print(self.left_group.get_end_effector_link())

        if self.made_it(pose_goal, left_EE_pose):
            print("Ready to grasp gun!")

        else:
            print("Not ready to grasp gun!")


        print("============ Press `Enter` to close left gripper")
        raw_input()
        self.left_gripper.close()



    def display_trajectory(self, plan):
        """ Published planned trajectory in rviz

        Args:
            plan (): motion plan to goal
        """

        display_traj = moveit_msgs.msg.DisplayTrajectory()
        display_traj.trajectory_start = self.robot.get_current_state()
        display_traj.trajectory.append(plan)
        self.display_trajectory_publisher.publish(display_traj);



    def get_transform(self, pose):
        """ computes the transformation matrix given a pose msg

        Args:
            pose (Pose): pose of a rigid body

        Returns:
            T (np.array): homogenous transformation matrix
        """

        quat_list = [pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w]

        homo_rot = quaternion_matrix(quat_list)

        T = np.array([[homo_rot[0][0], homo_rot[0][1], homo_rot[0][2], pose.position.x],
                      [homo_rot[1][0], homo_rot[1][1], homo_rot[1][2], pose.position.y],
                      [homo_rot[2][0], homo_rot[2][1], homo_rot[2][2], pose.position.z],
                      [0,              0,              0,              1]])


        return T


    def extract_pose(self, T):
        """ extracts the quaternion and translation vector from a homogenous
        tranformation matrix

        Args:
            T (np.array): homogenous transformation matrix

        Returns:
            quat (np.array): quaternion represting orientation of rigid body
            trans (np.array): translation vector represting position of rigid body
        """

        # extract euler angles
        rot = np.array([[T[0][0], T[0][1], T[0][2]],
                        [T[1][0], T[1][1], T[1][2]],
                        [T[2][0], T[2][1], T[2][2]]])


        ax, ay, az = euler_from_matrix(rot)
        quat = quaternion_from_euler(ax, ay, az)

        trans = np.array([T[0][3], T[1][3], T[2][3]])

        return quat, trans


    def made_it(self, goal, actual):
        """ Test if end effector made it to target

        Args:
        goal (Pose): target for robot
        actual (Pose): where robot actually is

        Returns:
        bool: True for success
        """

        goal = pose_to_list(goal)
        actual = pose_to_list(actual)

        for index in range(len(goal)):
            if abs(actual[index] - goal[index]) > self.tolerance:
                return False

        return True



    def add_box(self, timeout=4):
        """ Adds a box to rviz """

        # Add Objects to Planning Scene
        self.box_name = 'table'
        self.box_pose = PoseStamped()
        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.box_pose.header.frame_id = "base"
        self.box_pose.pose.position.x = 0.5
        self.box_pose.pose.position.z = -0.3095
        self.box_pose.pose.orientation.w = 1.0
        # Length, Width, Height
        self.scene.add_box(self.box_name, self.box_pose, size=(0.6, 0.8, 0.1))
        # return self.wait_for_state_update(box_is_known=True, timeout=timeout)



def main():

    #rospy.init_node("left_arm", anonymous=True)

    try:
        left_arm = LeftArm()

        #print("============ Press `Enter` to execute a movement using a pose goal")
        #raw_input()
        #left_arm.go_to_goal()
        #left_arm.test_waypoints()

        #print("============ Press `Enter` to close left gripper")
        #raw_input()
        #left_arm.left_gripper.close()


    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()




"""
pose_goal.orientation.x = 0.70
pose_goal.orientation.y = 0.027
pose_goal.orientation.z = 0.713
pose_goal.orientation.w = 0.04

pose_goal.position.x = 0.4 - self.standoff
pose_goal.position.y = 0.1
pose_goal.position.z = 0.4
"""










#
