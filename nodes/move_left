#!/usr/bin/env python

#from __future__ import division

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr


class LeftArm(object):
    """ manipulates baxters left arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(LeftArm, self).__init__()

        #joint_state_topic = ['joint_states:=/joint_states_desired']
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)

        rospy.init_node("left_arm", anonymous=True)


        baxter_interface.RobotEnable().enable()
        rospy.sleep(0.25)
        print("Baxter is enabled")


        #moveit_commander.roscpp_initialize(sys.argv)
        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()


        # add table
        self.add_box()


        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.tolerance = 0.01
        self.left_group.set_goal_position_tolerance(self.tolerance)
        self.left_group.set_goal_orientation_tolerance(self.tolerance)
        self.left_group.set_planning_time(5.0)
        self.left_group.allow_replanning(True)
        self.left_group.set_max_velocity_scaling_factor(0.6)
        self.left_group.set_max_acceleration_scaling_factor(0.6)

        # gripper
        self.left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        self.left_gripper.reboot()
        # Calibrate Gripper
        self.left_gripper.calibrate()
        # Open Gripper
        self.left_gripper.open()

        # Initialize attribute for desired EE Pose
        self.pose_goal = Pose()
        # Amount to pull back pre and post grip (approach, retreat)
        self.standoff = 0.1


        # trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)


        # subscribe to gun pose
        self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.gun_callback)

        #self.robot_state = self.robot.get_current_state()
        #print(self.robot_state)
        #print(self.left_group.get_current_pose().pose)
        #rospy.sleep(3)


        """
        self.planning_frame = self.left_group.get_planning_frame()
        rospy.loginfo("========== Reference frame: %s" % self.planning_frame)
        # Get End Effector link name for this group
        self.eef_link = self.left_group.get_end_effector_link()
        rospy.loginfo("========== End effector: %s" % self.eef_link)
        # Get list of all groups in the robot
        self.group_names = self.robot.get_group_names()
        rospy.loginfo("========== Robot Groups: %s" % self.robot.get_group_names())
        """


    def gun_callback(self, msg):
        """ callback for the pose of the gun

        Args:
            msg (Pose): pose of gun
        """






    def go_to_goal(self):
        """ moves baxters left end effector to a pose goal """


        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()

        pose_goal.orientation.x = 0.70
        pose_goal.orientation.y = 0.027
        pose_goal.orientation.z = 0.713
        pose_goal.orientation.w = 0.04

        pose_goal.position.x = 0.9 - self.standoff
        pose_goal.position.y = 0.14
        pose_goal.position.z = -0.225


        self.left_group.set_pose_target(pose_goal)

        # plan to path goal
        plan = self.left_group.plan()
        self.display_trajectory(plan)

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()

        # test if made it to pre-pick up position
        current_pose = self.left_group.get_current_pose().pose
        if self.made_it(pose_goal, current_pose):
            print("End Effector Behind gun!")

        else:
            print("End Effector did Not make it to gun!")


        print("============ Left Gripper Behind Gun")
        print("============ Press `Enter` to finish movement")
        raw_input()


        # position EE at handle of gun
        pose_goal = geometry_msgs.msg.Pose()

        pose_goal.orientation.x = 0.70
        pose_goal.orientation.y = 0.027
        pose_goal.orientation.z = 0.713
        pose_goal.orientation.w = 0.04

        pose_goal.position.x = 0.9
        pose_goal.position.y = 0.14
        pose_goal.position.z = -0.225
        

        self.left_group.set_pose_target(pose_goal)

        # plan to goal
        plan = self.left_group.plan()
        self.display_trajectory(plan)

        # execute path
        self.left_group.execute(plan, wait=True)
        self.left_group.stop()
        self.left_group.clear_pose_targets()


        #current_pose = self.left_group.get_current_pose(self.left_group.get_end_effector_link()).pose
        current_pose = self.left_group.get_current_pose().pose
        print(current_pose)
        #print(self.left_group.get_end_effector_link())

        if self.made_it(pose_goal, current_pose):
            print("Ready to grasp gun!")

        else:
            print("Not ready to grasp gun!")



    def display_trajectory(self, plan):
        """ Published planned trajectory in rviz

        Args:
            plan (): motion plan to goal
        """

        display_traj = moveit_msgs.msg.DisplayTrajectory()
        display_traj.trajectory_start = self.robot.get_current_state()
        display_traj.trajectory.append(plan)
        self.display_trajectory_publisher.publish(display_traj);



    def made_it(self, goal, actual):
        """ Test if end effector made it to target

        Args:
        goal (Pose): target for robot
        actual (Pose): where robot actually is

        Returns:
        bool: True for success
        """

        goal = pose_to_list(goal)
        actual = pose_to_list(actual)

        for index in range(len(goal)):
            if abs(actual[index] - goal[index]) > self.tolerance:
                return False

        return True



    def add_box(self, timeout=4):
        """ Adds a box to rviz """

        # Add Objects to Planning Scene
        self.box_name = 'table'
        self.box_pose = PoseStamped()
        # Can reference to base frame
        # Or can reference to EE finger frame
        # for grasping
        self.box_pose.header.frame_id = "base"
        self.box_pose.pose.position.x = 0.5
        self.box_pose.pose.position.z = -0.3095
        self.box_pose.pose.orientation.w = 1.0
        # Length, Width, Height
        self.scene.add_box(self.box_name, self.box_pose, size=(0.6, 0.8, 0.1))
        # return self.wait_for_state_update(box_is_known=True, timeout=timeout)



def main():

    #rospy.init_node("left_arm", anonymous=True)

    try:
        left_arm = LeftArm()

        print("============ Press `Enter` to execute a movement using a pose goal")
        raw_input()
        left_arm.go_to_goal()


        print("============ Press `Enter` to close left gripper")
        raw_input()
        left_arm.left_gripper.close()


    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()













#
