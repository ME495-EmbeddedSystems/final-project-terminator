#!/usr/bin/env python


"""

PUBLSIHERS:
    +

SUBSCRIBERS:
    +
"""

from __future__ import division

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr
from tf.transformations import quaternion_matrix
from tf.transformations import quaternion_from_euler
from tf.transformations import euler_from_matrix
from std_msgs.msg import Bool

from terminator import*


class LeftArm(object):
    """ manipulates baxters left arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(LeftArm, self).__init__()

        #joint_state_topic = ['joint_states:=/joint_states_desired']
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)


        # TODO: move this to the commander main node
        baxter_interface.RobotEnable().enable()
        rospy.sleep(0.25)
        print("Baxter is enabled")


        #moveit_commander.roscpp_initialize(sys.argv)
        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()

        # size of April tag
        # important for placement of gripper
        self.tag = 0.0873125


        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.position_tol = 0.03
        self.orientation_tol = 0.3

        self.left_group.set_goal_position_tolerance(self.position_tol)
        self.left_group.set_goal_orientation_tolerance(self.orientation_tol)
        self.left_group.set_planning_time(10.0)
        self.left_group.allow_replanning(True)
        self.left_group.set_max_velocity_scaling_factor(0.2)
        self.left_group.set_max_acceleration_scaling_factor(0.1)

        # gripper
        self.left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        self.left_gripper.reboot()
        # Calibrate Gripper
        self.left_gripper.calibrate()
        # Open Gripper
        self.left_gripper.open()

        self.orientation_x = -0.003
        self.orientation_y = 0.696
        self.orientation_z = -0.0048
        self.orientation_w = 0.717


        # Amount to pull back pre and post grip (approach, retreat)
        self.prestandoff = 0.15
        self.poststandoff = 0.2
        # vertical distance from gun to tag
        self.vert_tg = 0.2413

        # position adjustment parameters
        self.x_coord = 0.127
        self.y_coord = 0.0762
        self.z_coord = 0.0254

        # trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)


        # init pose goal for right EE
        init_goal = geometry_msgs.msg.Pose()
        init_goal.orientation.x = 0.065
        init_goal.orientation.y = 0.766
        init_goal.orientation.z = -0.022
        init_goal.orientation.w = 0.639

        init_goal.position.x = 0.415
        init_goal.position.y = 0.531
        init_goal.position.z = -0.15



        # place arm in init position
        #arm_init_pose(init_goal, self.left_group, self.position_tol, self.orientation_tol, "Left")
        self.shoot_pose()


        # status of baxter
        # is armed and is aiming
        self.armed = False
        self.is_aiming = False


        print("Done Initializing Baxter")


        # subscribe to gun pose
        #self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.go_to_goal)
        #self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.go_to_goal_waypoints)
        #self.gun_pose_sub = rospy.Subscriber('/gun_pose', Pose, self.pick_up_gun)
        self.gun_pose_sub = rospy.Subscriber('/targetBox', Point, self.aim)

        self.gun_pose_sub = rospy.Subscriber('/start_aiming', Bool, self.iniate_aiming)


        self.aim_pub = rospy.Publisher('/baxter_aiming', Bool, queue_size=10)





    def iniate_aiming(self, data):
        self.is_aiming = data.data






    def pick_up_gun(self, msg):
        """ callback function for Subscriber to /gun_pose

        The trajectory is divided into three stages

        1) move gripper to standoff location
        2) move gripper to handle
        3) grasp the gun
        4) pick up gun vertically to standoff location

        Args:
            msg (Pose): pose of the april tag
        """

        # stage 1
        print("============ Move to gun ============")
        pre_grasp = self.move_gripper(msg, pre_standoff=True)

        # stage 2
        print("============ Move to gun handle ============")
        grasp_handle = self.move_gripper(msg)

        # stage 3
        if pre_grasp and grasp_handle:
            print("============ Press `Enter` to close left gripper ============")
            raw_input()
            self.left_gripper.close()
            rospy.sleep(2)

        # stage 4
        print("============ Lift gun off Table ============")
        post_grasp = self.move_gripper(msg, post_standoff=True)




    def move_gripper(self, msg, pre_standoff=False, post_standoff=False):
        """ moves gripper to a goal pose

        Args:
            msg (Pose): pose of the april tag

        Returns:
            success (bool): True gripper makes it to pre-grasp standoff pose
        """

        # get pose of EE
        left_EE_pose = self.left_group.get_current_pose().pose

        # compute transformation of gun relative to EE
        Teg = get_transform(msg)

        Tbe = get_transform(left_EE_pose)
        # tranformation from baxter to gun
        Tbg = np.dot(Tbe, Teg)

        # pose of gun relative to baxter
        quat, trans = extract_pose(Tbg)


        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()

        if pre_standoff:
            print("pre-standoff")
            # translation is based on location of April tag
            # pose_goal.position.x = msg.position.x + left_EE_pose.position.x - self.standoff
            # pose_goal.position.y = msg.position.y + left_EE_pose.position.y + self.tag/2
            # pose_goal.position.z = msg.position.z + left_EE_pose.position.z + self.tag/2

            pose_goal.position.x = trans[0] - self.prestandoff
            pose_goal.position.y = trans[1] + self.tag/2 + self.y_coord
            pose_goal.position.z = trans[2] + self.tag/2 + self.vert_tg


        elif post_standoff:
            print("post-standoff")
            # lift gun off table vertically
            pose_goal.position.x = left_EE_pose.position.x
            pose_goal.position.y = left_EE_pose.position.y
            pose_goal.position.z = left_EE_pose.position.z + self.poststandoff

        else:
            print("grasp")
            # move to grasp pose
            pose_goal.position.x = left_EE_pose.position.x + self.x_coord
            pose_goal.position.y = left_EE_pose.position.y
            pose_goal.position.z = left_EE_pose.position.z + self.z_coord


        # use pre-defined orientation
        pose_goal.orientation.x = self.orientation_x
        pose_goal.orientation.y = self.orientation_y
        pose_goal.orientation.z = self.orientation_z
        pose_goal.orientation.w = self.orientation_w

        success = False

        while not success:
            # develop a trajectory of waypoints
            plan, fraction = plan_cartesian_path(left_EE_pose, pose_goal, self.left_group)

            print("The fraction of path covered")
            print(fraction)

            # display plan in rviz
            display_trajectory(plan, self.robot, self.display_trajectory_publisher)

            rospy.sleep(2)

            print("============ Press `Enter` to move gripper ============")
            raw_input()

            try:
                # execute path
                self.left_group.execute(plan, wait=True)
                self.left_group.stop()
                self.left_group.clear_pose_targets()

                # wait for baxter to get to goal
                rospy.sleep(2)

            except (rospy.ServiceException, rospy.ROSException), e:
                rospy.loginfo("Service call failed: %s" % (e,))

            # test if made it to pre-pick up position
            left_EE_pose = self.left_group.get_current_pose().pose

            if made_it(pose_goal, left_EE_pose, self.position_tol, self.orientation_tol):
                print("Goal Reached")
                success = True

            else:
                print("Goal Not Reached!")
                print("EE pose")
                print(left_EE_pose)

                print("Goal")
                print(pose_goal)

        return success



    def shoot_pose(self):
        # TODO: move to end of pick up gun
        ##########################################
        # move to initial shooting position
        # restrict z motion is x-axis
        # get pose of EE
        left_EE_pose = self.left_group.get_current_pose().pose


        pose_goal = geometry_msgs.msg.Pose()
        pose_goal.orientation.x = self.orientation_x
        pose_goal.orientation.y = self.orientation_y
        pose_goal.orientation.z = self.orientation_z
        pose_goal.orientation.w = self.orientation_w

        pose_goal.position.x = 0.87
        pose_goal.position.y = 0.30
        pose_goal.position.z = 0.20


        plan, fraction = plan_cartesian_path(left_EE_pose, pose_goal, self.left_group)
        print("The fraction of path covered")
        print(fraction)

        display_trajectory(plan, self.robot, self.display_trajectory_publisher)

        rospy.sleep(2)



        print("============ Press `Enter` to move to shooting pose ============")
        raw_input()

        try:
            # execute path
            self.left_group.execute(plan, wait=True)
            self.left_group.stop()
            self.left_group.clear_pose_targets()

            # wait for baxter to get to goal
            rospy.sleep(2)

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.loginfo("Service call failed: %s" % (e,))


        # test if made it to pre-pick up position
        left_EE_pose = self.left_group.get_current_pose().pose

        if made_it(pose_goal, left_EE_pose, self.position_tol, self.orientation_tol):
            print("Goal Reached")
        else:
            print("Goal Not Reached!")

        ##########################################





    def aim(self, msg):
        """ callback for subscriber to /targetBox

        Positions the y and z coordinates of the left EE to align with the target

        Args:
            msg (Point): x, y, and z location in pixels of target
        """

        # if requested to start aiming
        if self.is_aiming:

            print("==== AIMING ====")

            # goal tolerance in pixels
            tol = 20
            y_goal = 320
            z_goal = 320

            # in pixel coordinates, center of bounding box
            # coordinate axis is in baxters frame
            y_target = msg.x
            z_target = msg.y

            # amount to move EE
            dy = 0.0254
            dz = 0.0254


            # move in y direction until goal is met
            y_error = y_goal - y_target
            z_error = z_goal - z_target

            print("Y ERROR: ", y_error)
            print("Z ERROR: ", z_error)


            if abs(y_error) > tol or abs(z_error) > tol:

                # get state feedback
                left_EE_pose = self.left_group.get_current_pose().pose

                pose_goal = geometry_msgs.msg.Pose()
                pose_goal = left_EE_pose


                if abs(y_error) > tol:

                    # move arm to left
                    if y_error > 0:
                        print("Moving to the left")
                        pose_goal.position.y = left_EE_pose.position.y + dy

                    # move right:
                    else:
                        print("Moving to the right")
                        pose_goal.position.y = left_EE_pose.position.y - dy


                if abs(z_error) > tol:

                    # move arm to left
                    if z_error > 0:
                        print("Moving to the up")
                        pose_goal.position.z = left_EE_pose.position.z + dz

                    # move right:
                    else:
                        print("Moving to the down")
                        pose_goal.position.z = left_EE_pose.position.z - dz



                # plan and move
                plan, fraction = plan_cartesian_path(left_EE_pose, pose_goal, self.left_group)
                # execute path
                self.left_group.execute(plan, wait=True)
                self.left_group.stop()
                self.left_group.clear_pose_targets()

                rospy.sleep(0.5)


            # target is withing sight
            else:
                aim = Bool()
                aim.data = False
                self.aim_pub.Publish(aim)





def main():

    rospy.init_node("left_arm", anonymous=True)

    try:
        left_arm = LeftArm()

        #left_arm.aim()
        #print("============ Press `Enter` to execute a movement using a pose goal")
        # raw_input()
        # #left_arm.go_to_goal()
        # msg = geometry_msgs.msg.Pose()
        # msg.orientation.x = 0.027
        # msg.orientation.y = 0.76
        # msg.orientation.z = -0.020
        # msg.orientation.w = 0.65
        #
        # msg.position.x = 0.5
        # msg.position.y = 0
        # msg.position.z = 0
        #
        # #left_arm.go_to_goal_waypoints(msg)
        # left_arm.pick_up_gun(msg)
        # #print("============ Press `Enter` to close left gripper")
        #raw_input()
        #left_arm.left_gripper.close()


    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()












#
