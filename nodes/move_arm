#!/usr/bin/env python

#from __future__ import division

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr


class LeftArm(object):
    """ manipulates baxters left arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(LeftArm, self).__init__()
        # joint_state_topic = ['joint_states:=/joint_states_desired']
        # moveit_commander.roscpp_initialize(joint_state_topic)

        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()

        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.left_group.set_goal_position_tolerance(0.01)
        self.left_group.set_goal_orientation_tolerance(0.01)
        self.left_group.set_planning_time(5.0)
        self.left_group.allow_replanning(False)
        self.left_group.set_max_velocity_scaling_factor(0.6)
        self.left_group.set_max_acceleration_scaling_factor(0.6)

        # gripper
        self.left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        self.left_gripper.reboot()
        # Calibrate Gripper
        self.left_gripper.calibrate()
        # Open Gripper
        self.left_gripper.open()

        # Initialize attribute for desired EE Pose
        self.pose_goal = Pose()
        # Amount to pull back pre and post grip (approach, retreat)
        self.standoff = 0.1


        # Trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)


        #self.robot_state = self.robot.get_current_state()
        #print(self.robot_state)

        #rospy.sleep(3)


        """
        self.planning_frame = self.move_group.get_planning_frame()
        rospy.loginfo("========== Reference frame: %s" % self.planning_frame)
        # Get End Effector link name for this group
        self.eef_link = self.move_group.get_end_effector_link()
        rospy.loginfo("========== End effector: %s" % self.eef_link)
        # Get list of all groups in the robot
        self.group_names = self.robot.get_group_names()
        rospy.loginfo("========== Robot Groups: %s" % self.robot.get_group_names())
        """




    def go_to_goal(self):
        """ moves baxters left end effector to a pose goal """


        pose_goal = geometry_msgs.msg.Pose()
        pose_goal.orientation.w = 1.0
        pose_goal.position.x = 0.4
        pose_goal.position.y = 0.1
        pose_goal.position.z = 0.4

        self.left_group.set_pose_target(pose_goal)

        # Now, we call the planner to compute the plan and execute it.
        plan = self.left_group.go(wait=True)
        # Calling `stop()` ensures that there is no residual movement
        self.left_group.stop()
        # It is always good to clear your targets after planning with poses.
        # Note: there is no equivalent function for clear_joint_value_targets()
        self.left_group.clear_pose_targets()
        # For testing:
        # current_pose = self.move_group.get_current_pose().pose








def main():

    rospy.init_node("left_arm", anonymous=True)

    try:
        left_arm = LeftArm()

        print("============ Press `Enter` to execute a movement using a pose goal")
        raw_input()
        left_arm.go_to_goal()


        print("============ Press `Enter` to close left gripper")
        raw_input()
        left_arm.left_gripper.close()


    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()













#
