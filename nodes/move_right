#!/usr/bin/env python


"""

PUBLSIHERS:
    +

SUBSCRIBERS:
    +
"""

from __future__ import division

import sys
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr


from terminator import*


class RightArm(object):
    """ manipulates the right arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(RightArm, self).__init__()

        #joint_state_topic = ['joint_states:=/joint_states_desired']
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)



        # TODO: move this to the commander main node
        baxter_interface.RobotEnable().enable()
        rospy.sleep(0.25)
        print("Baxter is enabled")

        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()


        self.right_group = moveit_commander.MoveGroupCommander("right_arm")

        # left group is only to read pose of the gripper to
        # help position the right gripper
        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.position_tol = 0.03
        self.orientation_tol = 0.3

        self.right_group.set_goal_position_tolerance(self.position_tol)
        self.right_group.set_goal_orientation_tolerance(self.orientation_tol)
        self.right_group.set_planning_time(10.0)
        self.right_group.allow_replanning(True)
        self.right_group.set_max_velocity_scaling_factor(0.2)
        self.right_group.set_max_acceleration_scaling_factor(0.1)


        # gripper
        self.right_gripper = Gripper('right', CHECK_VERSION)
        # Reboot Gripper
        self.right_gripper.reboot()
        # Calibrate Gripper
        self.right_gripper.calibrate()
        # Open Gripper
        self.right_gripper.open()

        # gripper position tuning parameters
        self.d = 0.0762

        self.x_coord = 0.1016
        self.y_coord = 0.1143
        self.z_coord = 0.0508


        # trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)


        # init pose goal for left EE
        init_goal = geometry_msgs.msg.Pose()
        init_goal.orientation.x = -0.41
        init_goal.orientation.y = 0.60
        init_goal.orientation.z = 0.35
        init_goal.orientation.w = 0.58

        init_goal.position.x = 0.68
        init_goal.position.y = -0.25
        init_goal.position.z = 0.30


        # place arm in init position
        arm_init_pose(init_goal, self.right_group, self.position_tol, self.orientation_tol, "Right")

        print("Done Initializing Baxter")




    def position_trigger(self):
        """ places the right gripper at the trigger

        1) move gripper to stand off location
        2) place gripper on trigger

        """

        # stage 1
        print("============ Move to gun ============")

        right_EE_pose = self.right_group.get_current_pose().pose

        # place perpendicular to the left end effector
        left_EE_pose = self.left_group.get_current_pose().pose

        # transform from baxter to left gripper
        Tbl = get_transform(left_EE_pose)
        #Tbr = self.get_transform(right_EE_pose)

        #print("T from Baxter to Left Gripper")
        #print(Tbl)

        angle_x = -np.pi/2

        # transform from baxter to right gripper standoff
        T1 = np.array([[1,  0,               0,                     0],
                       [0,  np.cos(angle_x), -np.sin(angle_x),      0],
                       [0,  np.sin(angle_x),  np.cos(angle_x),      0],
                       [0,  0,               0,                     1]])

        T2 = np.array([[1, 0, 0,  -self.x_coord],
                       [0, 1, 0,  self.y_coord],
                       [0, 0, 1,  -self.z_coord],
                       [0, 0, 0,  1]])

        Tlrs = np.dot(T1, T2)


        Tbrs = np.dot(Tbl, Tlrs)
        #Tbrs = np.dot(Tbr, Tlrs)

        #print("T from Baxter to Right Gripper Standoff")
        #print(Tbrs)


        quat, trans = extract_pose(Tbrs)

        pose_goal = geometry_msgs.msg.Pose()

        pose_goal.position.x = trans[0]
        pose_goal.position.y = trans[1]
        pose_goal.position.z = trans[2]

        pose_goal.orientation.x = quat[0]
        pose_goal.orientation.y = quat[1]
        pose_goal.orientation.z = quat[2]
        pose_goal.orientation.w = quat[3]


        # plan from right EE to goal
        plan, fraction = plan_cartesian_path(right_EE_pose, pose_goal, self.right_group)

        print("The fraction of path covered")
        print(fraction)

        # display plan in rviz
        display_trajectory(plan, self.robot, self.display_trajectory_publisher)

        rospy.sleep(2)


        print("============ Press `Enter` to move gripper ============")
        raw_input()

        try:
            # execute path
            self.right_group.execute(plan, wait=True)
            self.right_group.stop()
            self.right_group.clear_pose_targets()

            # wait for baxter to get to goal
            rospy.sleep(4)

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.loginfo("Service call failed: %s" % (e,))



        # stage 2
        print("============ Move to trigger ============")

        right_EE_pose = self.right_group.get_current_pose().pose

        pose_goal.position.x = right_EE_pose.position.x
        pose_goal.position.y = right_EE_pose.position.y + self.d
        pose_goal.position.z = right_EE_pose.position.z

        pose_goal.orientation.x = right_EE_pose.orientation.x
        pose_goal.orientation.y = right_EE_pose.orientation.y
        pose_goal.orientation.z = right_EE_pose.orientation.z
        pose_goal.orientation.w = right_EE_pose.orientation.w


        # plan from right EE to goal
        plan, fraction = plan_cartesian_path(right_EE_pose, pose_goal, self.right_group)

        print("The fraction of path covered")
        print(fraction)

        # display plan in rviz
        display_trajectory(plan, self.robot, self.display_trajectory_publisher)

        rospy.sleep(2)



        print("============ Press `Enter` to move gripper ============")
        raw_input()

        try:
            # execute path
            self.right_group.execute(plan, wait=True)
            self.right_group.stop()
            self.right_group.clear_pose_targets()

            # wait for baxter to get to goal
            rospy.sleep(4)

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.loginfo("Service call failed: %s" % (e,))



        # stage 3
        print("============ Press `Enter` to close left gripper ============")
        raw_input()
        self.right_gripper.close()
        rospy.sleep(2)

        self.right_gripper.open()




def main():
    rospy.init_node("right_arm", anonymous=True)

    try:
        right_arm = RightArm()

        right_arm.position_trigger()

    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()




















#
