#!/usr/bin/env python


import sys
import rospy
import copy
import baxter_interface
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
from tf.transformations import quaternion_from_euler
from terminator import*

class AimTarget(object):
	""" manipulates baxters left arm """

	def __init__(self):

		rospy.loginfo("Ready for aim_target")
		super(AimTarget, self).__init__()
		# First initialize moveit_commander and a rospy node:
		moveit_commander.roscpp_initialize(sys.argv)
		rospy.init_node("aim_target", anonymous=True)
		# Instantiate a RobotCommander object. 
		joint_state_topic = ['joint_states:=/robot/joint_states']
		moveit_commander.roscpp_initialize(joint_state_topic)
		# self.add_box()
		self.robot = moveit_commander.RobotCommander()
		# Instantiate a PlanningSceneInterface object. 
		self.scene = moveit_commander.PlanningSceneInterface()
		# Instantiate a MoveGroupCommander object. This object is an interface to a planning group
		baxter_interface.RobotEnable().enable()
		rospy.sleep(0.25)
		rospy.loginfo("Ready for aim_target")

		self.aim_group = moveit_commander.MoveGroupCommander('left_arm')
		self.position_tolerance = 0.05
		self.orientation_tolerance = 0.3
		self.aim_group.set_goal_position_tolerance(self.position_tolerance)
		self.aim_group.set_goal_orientation_tolerance(self.orientation_tolerance)
		# self.aim_group.set_planner_id('RRTConnectkConfigDefault')
		# self.aim_group.set_planning_time(30)
		# self.aim_group.allow_replanning(True)
		# self.aim_group.set_max_velocity_scaling_factor(0.6)
		# self.aim_group.set_max_acceleration_scaling_factor(0.6)

		
		# initialize error
		self.y_err_i = 0
		self.z_err_i = 0
		#subscribe to /TargetBox
		self.target_pose = rospy.Subscriber('/targetBox', Point, self.aim_goal)
		self.display_trajectory_publisher = rospy.Publisher(
			'/move_group/display_planned_path',
			moveit_msgs.msg.DisplayTrajectory,
			queue_size=20)
		# get the name of the reference frame for this robot:
		planning_frame = self.aim_group.get_planning_frame()
		print "============ Planning frame: %s" % planning_frame     

	
		# subscribe to targetBox
		# self.gun_pose_sub = rospy.Subscriber("/targetBox", BoundingBoxes, self.aim_goal)

	   

	# def aim_goal(self, msg):
	#     """ callback for the target position
	#     Args:
	#    
	#     """





		
	def aim_goal(self,msg):

		# These code are for aiming the target cup
		
		# frame center in pixel coordinates
		# full image is 640 * 400 ???
		y_ref = 640/2
		z_ref = 400/2
		diff = 5
		# center of the cup in pixel coordinates
		y_target = msg.x
		z_target = msg.y
		# distance to move
		# y_err = y_ref -  y_target
		# z_err = z_ref -  z_target
		y_err = y_target - y_ref 
		z_err = z_target - z_ref
		print("Y error is : ", y_err)
		print("Z error is : ", z_err)

		# dy = 0.0254
		# dz = 0.0254
		
		# feedback control gains
		KP_y = 0.05
		KP_z = 0.5
		KI_y = 0.01
		KI_z = 0.01
		
		if abs(y_err) > diff or abs(z_err) > diff:
			current_pose = self.aim_group.get_current_pose().pose
			aim_goal = geometry_msgs.msg.Pose()
			aim_goal = current_pose

			# get state feedback

			print("current_pose_y is :",current_pose.position.y)
			print("current_pose_z is :",current_pose.position.z)
		
			
			aim_goal.position.x = current_pose.position.x
			aim_goal.position.y = current_pose.position.y + KP_y*y_err + KI_y * (self.y_err_i + y_err * 0.005 )
			self.y_err_i += y_err*0.005

			aim_goal.position.z = current_pose.position.z + KP_z*z_err + KI_z * (self.z_err_i + z_err * 0.005 )
			self.z_err_i += z_err*0.005

			aim_goal.orientation.x = -0.003
			aim_goal.orientation.y = 0.696
			aim_goal.orientation.z = -0.0048
			aim_goal.orientation.w = 0.717
			

			# q = quaternion_from_euler(3.14, 1.5707, 3.14)
			# aim_goal.orientation.x = q[0]
			# aim_goal.orientation.y = q[1]
			# aim_goal.orientation.z = q[2]
			# aim_goal.orientation.w = q[3]	



			# if abs(y_err) > diff:

			# 	# move  left
			# 	if y_err > 0:
			# 		print("Moving left")
			# 		aim_goal.position.y = current_pose.position.y + dy

			# 	# move right:
			# 	else:
			# 		print("Moving right")
			# 		aim_goal.position.y = current_pose.position.y - dy


			# if abs(z_err) > diff:
			# 	if z_err > 0:
			# 		print("Moving up")
			# 		aim_goal.position.z = current_pose.position.z + dz

			# 	# move downt:
			# 	else:
			# 		print("Moving down")
			# 		aim_goal.position.z = current_pose.position.z - dz


			# self.aim_group.set_pose_target(aim_goal)
			# self.aim_group.set_start_state_to_current_state()        

			# # plan to move
			# plan, fraction = plan_cartesian_path(current_pose, aim_goal, self.aim_group)
			# self.display_trajectory(plan, self.robot, self.display_trajectory_publisher)
			# # excute
			# confirmed = raw_input('Execute aim_target? y/n')
			# if confirmed == "y":
			# 	self.aim_group.execute(plan, wait=True)        
			# 	self.aim_group.stop()
			# 	self.aim_group.clear_pose_targets()

			
			# print("current_pose is:")
			# print(current_pose) 
			# print("the goal pose is :")
			# print(aim_goal)

			# if self.check_aim(aim_goal, current_pose):
			# 	print("Aiming!")

			# else:
			# 	print("Not Aiming!")


			rospy.sleep(0.5)


		# target is withing sight
		else:
			pass


	


		""" moves baxter's left hand to a pose goal(wrote before realize darknet_ros can only give me
		the pixel coordinate instead of coordinate in the world frame) """	

		# aim_goal = geometry_msgs.msg.Pose()

		# # try to set the orientation constant:

		# q = quaternion_from_euler(3.14, 1.5707, 3.14)
		# aim_goal.orientation.x = q[0]
		# aim_goal.orientation.y = q[1]
		# aim_goal.orientation.z = q[2]
		# aim_goal.orientation.w = q[3]	
	
		# aim_goal.position.x = 0.832159
		# aim_goal.position.y = 0.531532
		# aim_goal.position.z = -0.10953
	
        ###########
		
		# possible position:

		# aim_goal.orientation.x = -0.618235
		# aim_goal.orientation.y = 0.784464
		# aim_goal.orientation.z = 0.016503
		# aim_goal.orientation.w = 0.0461452	

		# aim_goal.position.x = -0.205829
		# aim_goal.position.y = 0.654037
		# aim_goal.position.z = -0.389637


		# #initial configuration

		# aim_goal.orientation.x = 0.065
		# aim_goal.orientation.y = 0.766
		# aim_goal.orientation.z = -0.022
		# aim_goal.orientation.w = 0.639

		# aim_goal.position.x = 0.415
		# aim_goal.position.y = 0.531
		# aim_goal.position.z = -0.15

		self.aim_group.set_pose_target(aim_goal)
		self.aim_group.set_start_state_to_current_state()        
		# plan to path goal

		plan = self.aim_group.plan()
		self.display_trajectory(plan)

		# execute plan
		confirmed = raw_input('Execute aim_target? y/n')
		if confirmed == "y":
			self.aim_group.execute(plan, wait=True)        
			self.aim_group.stop()
			self.aim_group.clear_pose_targets()

		current_pose = self.aim_group.get_current_pose().pose
		print("current_pose is:")
		print(current_pose)
		print("the goal pose is :")
		print(aim_goal)

		if self.check_aim(aim_goal, current_pose):
			print("Aiming!")

		else:
			print("Not Aiming!")


		

	def display_trajectory(self, plan):
		""" Published planned trajectory in rviz
		Args:
			plan (): motion plan to goal
		"""

		display_traj = moveit_msgs.msg.DisplayTrajectory()
		display_traj.trajectory_start = self.robot.get_current_state()
		display_traj.trajectory.append(plan)
		self.display_trajectory_publisher.publish(display_traj);

	def check_aim(self, goal, actual):
		""" Test if end effector made it to target
		Args:
		goal (Pose): target for robot
		actual (Pose): where robot actually is
		Returns:
		bool: True for success
		"""

		goal = pose_to_list(goal)
		actual = pose_to_list(actual)

		for index in range(len(goal)):
			if abs(actual[index] - goal[index]) > 1:
				return False

		return True
	




def main():

	try:
		aim_target = AimTarget()
		# use it if not subscribe to any topic
		# action = raw_input("(A)im the target?")
		# if (action == "A"):
		# 	aim_target.aim_goal()

	except rospy.ROSInterruptException:
		return
	except KeyboardInterrupt:
		return

	rospy.spin()


if __name__ == '__main__':
	main()






